1) Create VM instance ->ubuntu
2) Connect SSH
_______________old way________________________
3) Create User
sudo adduser apps
sudo usermod -aG sudo apps
su apps
sudo ls
exit
su - apps

4) Install Docker and Docker Compose

sudo apt-get -y update
curl -fsSL https://download.docker.com/linux/ubu... | sudo apt-key add -
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
sudo apt-get install -y docker-ce

sudo curl -L "https://github.com/docker/compose/rel... -s)-$(uname -m)" -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose

sudo groupadd docker
sudo usermod -aG docker $USER


__________________modern way________________

sudo apt update
sudo apt install -y docker.io docker-compose-plugin

sudo usermod -aG docker $USER

exit 
//start a new shell

docker run hello-world

sudo apt install -y git

git clone [YOUR_REPO_URL]

cd lab2_microservices

docker compose up --build -d

docker compose ps

Crucial Check: Ensure you correctly created the Firewall Rule in Phase 1 to open port 80 (for Nginx) and ports 3001/3002 (for direct testing), otherwise, external access will fail.

gcloud compute firewall-rules create allow-microservice-ports \
    --allow tcp:80,tcp:3001,tcp:3002 \
    --target-tags http-docker-app \
    --description "Allow HTTP and direct service ports"

# Test User Service
curl http://[EXTERNAL_IP]/users 

# Test Post Service
curl http://[EXTERNAL_IP]/posts

docker compose down


_________using terraform______________________

git clone https://github.com/krupss555/lab5_nginx.git
cd lab5_nginx

export PROJECT_ID="[YOUR_PROJECT_ID]"
export REGION="us-central1" # Or your region
export AR_REPO="microservices-repo"

# Enable necessary GCP APIs and authenticate Docker
gcloud services enable container.googleapis.com artifactregistry.googleapis.com
gcloud artifacts repositories create $AR_REPO --repository-format=docker --location=$REGION
gcloud auth configure-docker $REGION-docker.pkg.dev

# 2a. Build & Push User Service (listens on internal container port 3001)
docker build ./user-service -t $REGION-docker.pkg.dev/$PROJECT_ID/$AR_REPO/user-service:v1
docker push $REGION-docker.pkg.dev/$PROJECT_ID/$AR_REPO/user-service:v1

# 2b. Build & Push Post Service (listens on internal container port 3002)
docker build ./post-service -t $REGION-docker.pkg.dev/$PROJECT_ID/$AR_REPO/post-service:v1
docker push $REGION-docker.pkg.dev/$PROJECT_ID/$AR_REPO/post-service:v1

cd gke_simple_tf
terraform init

terraform plan

terraform apply
# Type 'yes' when prompted.

terraform destroy


____________Kubernetes__________________
gcloud auth login
gccloud config set project <project id>

enable kubernetes apis, artifactregistry apis , create cluster , create artifactregistry repo 

HOW TO BUILD and PUSH docker images to artifactregistry

1)docker images
2) git clone
3) ls , cd repo
4) cat Dockerfile
5) docker build -t name_image:tag_name .
6) docker images 
7) docker tag name_image:tag_name path_to_repoAR/name_image:tag_name
8) docker images
9) docker push path_to_repoAR/name_image:tag_name

10)cloud container clusters get-credentials my-manual-cluster --zone us-central1-c
11)kubectl apply -f microservice-deploy.yaml
12)kubectl get service service_name
13)curl http://[EXTERNAL-IP]:port/


____Readme for kubernetes_
Steps
 Create a kubernetes cluster on GKE.
 Setup Connection to created GKE cluster in with your local machine or cloud shell.
gcloud container clusters get-credentials <CLUSTER_NAME> --zone <ZONE> --project <PROJECT_ID>
 Create a simple nodejs/express application.
 Write Dockerfile for the application
FROM --platform=linux/amd64 node:14
WORKDIR /usr/app
COPY package.json .
RUN npm install
COPY . .
EXPOSE 80
CMD ["node","app.js"]
 Build the Docker image
docker build -t us.gcr.io/<PROJECT_ID>/imagename:tag .
 Authenticate to GCR
gcloud auth configure-docker
 Push docker image to GCR(Google Container Registry)
docker push us.gcr.io/<PROJECT_ID>/imagename:tag
 Test the application using docker.
docker run -d -p 3000:80 us.gcr.io/<PROJECT_ID>/imagename:tag
 Write kubernetes manifest file for deployment. deploy.yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name:  nodeappdeployment
  labels:
    type: backend
    app: nodeapp
spec:
  replicas: 1
  selector:
    matchLabels:
      type: backend
      app: nodeapp
  template:
    metadata:
      name: nodeapppod
      labels:
        type: backend
        app: nodeapp
    spec:
      containers:
        - name: nodecontainer
          image: us.gcr.io/<PROJECT_ID>/imagename:tag
          ports:
            - containerPort: 80
 Write kubernetes manifest file for service. service.yml
kind: Service
apiVersion: v1
metadata:
  name: nodeapp-load-service
spec:
  ports:
    - port: 80 
      targetPort: 80
  selector:
    type: backend
    app: nodeapp  
  type: LoadBalancer
 Apply manifest file to create deployment.
kubectl apply -f deploy.yml
 Check status of the deployment.
kubectl get deploy
 Apply manifest file to create load balancer service.
kubectl apply -f service.yml
 Check status of service.
kubectl get svc
 Check the external IP of the service in the browser.
Cleanup
kubectl delete -f deploy.yml
kubectl delete -f service.yml

____________Github Actions______________

